%{
/*
	Analizador Lexico da Linguagem P++
	Equipe: Breno Cardoso, Lucas Simonetti, Renato Higor, Sidemar Fideles

	--Para compilar e executar
	lex lexicAnalizer.l
	cc lex.yy.c -ll -o lexicAnalizer
	./lexicAnalizer examples/arquivo.ppp

	#include "y.tab.h"
*/
%}

LETTER				[a-zA-Z]
DIGIT				[0-9]
NUMBER_INT			{DIGIT}+
NUMBER_REAL 			{NUMBER_INT}"."{NUMBER_INT}(e{NUMBER_INT})?s
ID	 			({LETTER}|_)({LETTER}|{DIGIT}|_)*


%%
[\t ]+ /* ignorar espa√ßos em branco */;
\"(\\.|[^\\"])*\" { printf("%s: token VAL_STRING\n", yytext); } 

procedure { printf("%s: token PROCEDURE\n", yytext); }
function { printf("%s: token FUNCTION\n", yytext); }

ref { printf("%s: token REF\n", yytext); }
var { printf("%s: token VAR\n", yytext); }
const { printf("%s: token CONST\n", yytext); }
int { printf("%s: token INT\n", yytext); }
real { printf("%s: token REAL\n", yytext); }
string { printf("%s: token STRING\n", yytext); }
boolean { printf("%s: token BOOLEAN\n", yytext); }

true { printf("%s: token TRUE\n", yytext); }
false { printf("%s: token FALSE\n", yytext); }

null {printf("%s: token NULL \n", yytext); }

begin { printf("%s: token BEGIN\n", yytext); }
end { printf("%s: token END\n", yytext); }

return { printf("%s: token RETURN\n", yytext); }
break { printf("%s: token BREAK\n", yytext); }
if { printf("%s: token IF\n", yytext); }
then { printf("%s: token THEN\n", yytext); }
else { printf("%s: token ELSE\n", yytext); }
switch { printf("%s: token SWITCH\n", yytext); }
case { printf("%s: token CASE\n", yytext); }
default { printf("%s: token DEFAULT\n", yytext); }
for { printf("%s: token FOR\n", yytext); }
downto { printf("%s: token DOWNTO\n", yytext); }
to { printf("%s: token TO\n", yytext); }
do { printf("%s: token DO\n", yytext); }
loop { printf("%s: token LOOP\n", yytext); }
exit { printf("%s: token EXIT\n", yytext); }
when { printf("%s: token WHEN\n", yytext); }

{ID} { printf("%s: token ID \n", yytext);}
{NUMBER_INT} { printf("%s: token NUMBER_INT \n", yytext); }
{NUMBER_REAL} { printf("%s: token NUMBER_REAL \n", yytext); }

";" { printf("%s: token SEMICOLON\n ", yytext); }	
"," { printf("%s: token COMMA \n", yytext); }		
"."	{ printf("%s: token DOT\n", yytext); }		
"(" { printf("%s: token OPEN_PARENTHESIS\n", yytext); }
")"	{ printf("%s: token CLOSE_PARENTHESIS\n", yytext); }
"[" { printf("%s: token OPEN_BRACKETS\n", yytext); }
"]" { printf("%s: token CLOSE_BRACKETS\n", yytext); }
"{" { printf("%s: token OPEN_BRACES\n", yytext); }
"}" { printf("%s: token CLOSE_BRACES\n", yytext); }


"+" { printf("%s: token ADD\n", yytext); }
"-" { printf("%s: token SUB\n", yytext); }
"*" { printf("%s: token MULT\n", yytext);}	
"/" { printf("%s: token DIV\n", yytext); }
"=" { printf("%s: token EQUAL\n", yytext); }
"%" { printf("%s: token MOD\n", yytext); }
"!" { printf("%s: token NEG\n", yytext); }
"||" { printf("%s: token OR\n", yytext); }
"&&" { printf("%s: token AND\n", yytext); }
"<" { printf("%s: token LESS_THEN\n", yytext); }
">" { printf("%s: token BIGGER_THEN\n", yytext); }
"==" { printf("%s: token EQUAL_LOGIC\n", yytext); }
"!=" { printf("%s: token NOT_EQUAL\n", yytext); }
"<=" { printf("%s: token LESS_EQUAL\n", yytext); }
">=" { printf("%s: token BIGGER_EQUAL\n", yytext); }
"++" { printf("%s: token INCREMENT\n", yytext); }
"--" { printf("%s: token DECREMENT\n", yytext); }


.|\n { ECHO; }
%%

int main(argc,argv)
int argc;
char **argv;
{

	if (argc > 1) {
		FILE *file;

		file = fopen(argv[1], "r");
		if (!file) {
			fprintf(stderr,"could not open %s\n",argv[1]);
			exit(1);
		}
		yyin = file;
	}

	yylex();
	return 0;
}

int yywrap()
{
	return(1);
}
